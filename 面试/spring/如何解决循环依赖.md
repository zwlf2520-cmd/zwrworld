# Spring 如何解决循环依赖？

## 回答重点

Spring 通过**三级缓存**机制来解决循环依赖问题。

### 什么是循环依赖

循环依赖是指两个或多个 Bean 相互依赖，形成一个环形的依赖关系。例如：

```
A 依赖 B，B 依赖 A
```

或者更复杂的情况：

```
A 依赖 B，B 依赖 C，C 依赖 A
```

### Spring 解决循环依赖的三级缓存机制

Spring 在 `DefaultSingletonBeanRegistry` 类中维护了三个 Map 缓存：

```java
// 一级缓存：完全初始化好的 Bean（最终的 Bean）
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>();

// 二级缓存：实例化完成，但未初始化的半成品 Bean（早期的 Bean 引用）
private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>();

// 三级缓存：存储 ObjectFactory，用于创建 Bean（原始工厂方法）
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>();
```

### 解决流程详解

以 A 依赖 B，B 依赖 A 为例：

#### 1. 创建 A 的过程

```
1. Spring 检查 singletonObjects（一级缓存）中是否存在 A → 不存在
2. 开始创建 A，并将其对应的 ObjectFactory 放入 singletonFactories（三级缓存）
3. A 的构造函数执行完成（此时 A 是半成品，还没有注入属性）
4. Spring 发现 A 需要注入 B（A 的属性依赖）
5. 尝试获取 B
```

#### 2. 创建 B 的过程

```
1. Spring 检查 singletonObjects（一级缓存）中是否存在 B → 不存在
2. 开始创建 B，并将其对应的 ObjectFactory 放入 singletonFactories（三级缓存）
3. B 的构造函数执行完成（此时 B 是半成品）
4. Spring 发现 B 需要注入 A（B 的属性依赖）
5. 尝试获取 A → 这里是关键！
```

#### 3. 获取 A 的过程（关键步骤）

```
1. Spring 检查 singletonObjects（一级缓存）中是否存在 A → 不存在
2. Spring 检查 earlySingletonObjects（二级缓存）中是否存在 A → 不存在
3. Spring 检查 singletonFactories（三级缓存）中是否存在 A 的 ObjectFactory → 存在！
4. 调用 ObjectFactory.getObject() 获取 A 的早期引用（半成品 A）
5. 将 A 从三级缓存移除，放入二级缓存
6. 返回这个半成品的 A 给 B
```

#### 4. B 完成初始化

```
1. B 拿到 A 的引用后，完成初始化
2. B 放入一级缓存 singletonObjects
3. 将 B 从三级缓存移除
```

#### 5. A 完成初始化

```
1. A 现在能获取到已初始化的 B
2. A 完成初始化
3. A 从二级缓存移除，放入一级缓存 singletonObjects
```

### 代码示例

```java
// 循环依赖示例
@Component
public class A {
    @Autowired
    private B b;
  
    public void doSomething() {
        b.doSomething();
    }
}

@Component
public class B {
    @Autowired
    private A a;
  
    public void doSomething() {
        a.doSomething();
    }
}
```

## 注意事项

### ✅ 可以解决的循环依赖

- **属性注入（Setter 注入）**：通过 `@Autowired` 注入属性时的循环依赖
- **默认情况**：Spring 默认支持通过三级缓存解决属性级别的循环依赖

### ❌ 无法解决的循环依赖

- **构造函数注入**：通过构造函数参数注入时的循环依赖，Spring 无法解决

```java
// ❌ 会报错：BeanCurrentlyInCreationException
@Component
public class A {
    private B b;
  
    // 构造函数注入
    public A(B b) {
        this.b = b;
    }
}

@Component
public class B {
    private A a;
  
    public B(A a) {
        this.a = a;
    }
}
```

**原因**：构造函数注入时，对象还没有实例化，无法创建半成品对象放入缓存。

### 优缺点


| 特性               | 三级缓存     | @Lazy                |
| ------------------ | ------------ | -------------------- |
| **创建时机**       | 立即创建     | 延迟创建             |
| **代码侵入性**     | 无需修改代码 | 需要添加 @Lazy 注解  |
| **首次使用的性能** | 无影响       | 首次使用时有创建开销 |
| **是否创建代理**   | 自动处理 AOP | 需要配置             |
| **使用场景**       | 一般情况推荐 | 想要延迟加载时       |

扩展知识

### 为什么需要三级缓存？为什么不用二级缓存？

**二级缓存不够的原因**：如果只有二级缓存，对于需要代理的 Bean（如 AOP），会出现问题：

- 当 Bean 需要进行 AOP 代理时，在二级缓存中放入的是**原始对象**。
- 但最终一级缓存中应该放入的是**代理对象**。
- 这样就会导致获取到的不是同一个对象，破坏了单例原则。

**三级缓存的作用**：

- 三级缓存存储的是 `ObjectFactory`（工厂方法），而不是对象。
- 当需要提前获取 Bean 时，调用 `ObjectFactory.getObject()` 会自动进行 AOP 代理。
- 这样保证了获取到的总是**最终的、代理后的对象**。

```java
// 伪代码：ObjectFactory 的作用
ObjectFactory<Bean> factory = () -> {
    Bean bean = createBean();  // 创建原始对象
    return wrapIfNecessary(bean);  // 如果需要则进行 AOP 代理
};

// 获取时，自动获得代理后的对象
Bean bean = factory.getObject();
```

## 总结


| 缓存     | 存储内容              | 用途                    |
| -------- | --------------------- | ----------------------- |
| 一级缓存 | 完全初始化的 Bean     | 最终使用，保证单例      |
| 二级缓存 | 半成品 Bean（用过的） | 避免重复创建，快速查找  |
| 三级缓存 | ObjectFactory         | 延迟创建，支持 AOP 代理 |

Spring 通过三级缓存机制，巧妙地解决了属性注入循环依赖的问题，同时保证了 AOP 代理的正确性和 Bean 的单例特性。


## @Lazy 延迟初始化方法

`@Lazy` 是另一种解决循环依赖的方法，但原理与三级缓存不同。

### 工作原理

```java
@Component
public class A {
    @Autowired
    @Lazy  // 关键：延迟初始化 B
    private B b;
}

@Component
public class B {
    @Autowired
    private A a;  // 正常初始化 A
}
```

**执行流程**：

1. Spring 开始创建 A
2. A 中的 `b` 被标记为 `@Lazy`，Spring **不会立即创建 B 的真实对象**
3. 而是为 B 创建一个**代理对象**，注入到 A 中
4. 此时 A 的初始化完成，B 的真实对象还未创建
5. Spring 继续创建 B
6. B 正常注入 A（已完成初始化）
7. B 初始化完成
8. 当 A 第一次使用 B 时，代理对象才会实际创建 B 的真实对象

## @Lazy 详细示例

### 示例 1：基本用法

```java
@Component
public class UserService {
    @Autowired
    @Lazy  // 延迟初始化 OrderService
    private OrderService orderService;
  
    public void getUser(String id) {
        // 这里的代码不会触发 OrderService 的创建
        System.out.println("Getting user: " + id);
    }
  
    public void createOrder(String userId, String orderId) {
        // 第一次使用 OrderService 时，才会真正创建它
        orderService.createOrder(userId, orderId);
    }
}

@Component
public class OrderService {
    @Autowired
    private UserService userService;  // 正常注入
  
    public void createOrder(String userId, String orderId) {
        // 使用 userService
        userService.getUser(userId);
    }
}
```

### 示例 2：与 @Lazy 在类级别上使用

```java
@Component
@Lazy  // 整个 Bean 延迟初始化
public class HeavyService {
    public void doExpensiveOperation() {
        System.out.println("Doing expensive operation...");
    }
}

@Component
public class LightService {
    @Autowired
    private HeavyService heavyService;  // 注入的是代理对象
  
    public void lightOperation() {
        System.out.println("Light operation");
        // 第一次调用 HeavyService 时，才触发初始化
        heavyService.doExpensiveOperation();
    }
}
```

### 示例 3：与 ObjectProvider 配合

```java
@Component
public class A {
    @Autowired
    private ObjectProvider<B> bLazy;  // 更明确的延迟注入
  
    public void doSomething() {
        // 获取 B 的代理，延迟初始化
        B b = bLazy.getIfAvailable();
        if (b != null) {
            b.doSomething();
        }
    }
}

@Component
public class B {
    @Autowired
    private A a;
  
    public void doSomething() {
        a.doSomething();
    }
}
```

### 示例 4：@Lazy 在构造函数注入中使用

```java
@Component
public class A {
    private B b;
  
    // 注意：@Lazy 需要配合方法或 ObjectProvider 使用
    public A(ObjectProvider<B> bProvider) {
        // 这里不会立即初始化 B
        this.b = bProvider.getIfAvailable();
    }
}

@Component
public class B {
    private A a;
  
    public B(A a) {
        this.a = a;
    }
}
```

## @Lazy 的内部机制

Spring 在处理 `@Lazy` 注解时，会使用 **CGLIB 或 JDK 动态代理** 创建一个代理对象：

```java
// 简化的伪代码
if (field.hasAnnotation(Lazy.class)) {
    // 创建代理对象，而不是真实对象
    Object proxy = createProxy(beanClass, new LazyInitTargetSourceImpl(beanName));
    field.set(instance, proxy);
} else {
    // 立即创建真实对象
    Object realBean = createBean(beanName);
    field.set(instance, realBean);
}
```

当代理对象的任何方法被调用时，才会真正初始化真实对象。

## 对比：三级缓存 vs @Lazy vs ObjectProvider

```java
// 1. 三级缓存（默认机制，无需改代码）
@Component
public class A {
    @Autowired
    private B b;  // Spring 自动通过三级缓存处理
}

// 2. @Lazy（需要添加注解）
@Component
public class A {
    @Autowired
    @Lazy
    private B b;  // 创建代理，延迟初始化
}

// 3. ObjectProvider（推荐用于构造函数注入）
@Component
public class A {
    private B b;
  
    public A(ObjectProvider<B> bProvider) {
        this.b = bProvider.getIfAvailable();
    }
}
```

## 什么时候使用 @Lazy？

✅ **推荐使用 @Lazy 的场景**：

1. **构造函数注入**：解决构造函数循环依赖的最佳方案

   ```java
   public A(B b) {
       this.b = b;  // 无法解决循环依赖
   }
   ```
2. **重型 Bean 的延迟加载**：Bean 初始化成本高，不需要在启动时创建

   ```java
   @Lazy
   @Component
   public class DatabaseConnectionPool {
       // 连接池初始化成本高
   }
   ```
3. **减少启动时间**：应用启动时，某些 Bean 不必立即初始化

   ```java
   @Lazy
   @Component
   public class ReportGenerator {
       // 报表生成器可以延迟加载
   }
   ```
4. **可选依赖**：某个依赖可能不存在，需要运行时判断

   ```java
   @Autowired
   @Lazy
   private OptionalService optionalService;
   ```

❌ **不推荐使用 @Lazy 的场景**：

1. **启动时需要验证的 Bean**：应该在启动时立即发现问题
2. **高频访问的 Bean**：每次访问都需要通过代理，有性能开销
3. **简单属性注入**：使用三级缓存更高效

### 解决方案

**方案 1：改用 Setter 注入**

```java
@Component
public class A {
    private B b;
  
    @Autowired
    public void setB(B b) {
        this.b = b;
    }
}

@Component
public class B {
    private A a;
  
    @Autowired
    public void setA(A a) {
        this.a = a;
    }
}
```

**方案 2：使用 `@Lazy` 延迟初始化**

```java
@Component
public class A {
    @Autowired
    @Lazy
    private B b;
}

@Component
public class B {
    @Autowired
    private A a;
}
```

**方案 3：使用 `ObjectFactory` 或 `ObjectProvider`**

```java
@Component
public class A {
    @Autowired
    private ObjectProvider<B> bProvider;
  
    public void doSomething() {
        B b = bProvider.getIfAvailable();
        if (b != null) {
            b.doSomething();
        }
    }
}
```

##
