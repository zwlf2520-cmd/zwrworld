这块内容是架构设计中**最容易把人绕晕**的部分。因为名词太多：OAuth2, OIDC, JWT, CAS, SSO……

对于 35 岁的架构师，面试官问这个，其实是在问：**“你的微服务是裸奔的吗？如果不是，怎么高效地管住这么多服务的门？”**

咱们用**“去酒店开房”**的逻辑，把这些概念一次性降维打击掉。

---

### 🔥 话题二十二：微服务认证与 SSO（一把钥匙开万门）

#### 1. 生产环境事故：Session 共享的噩梦

**场景：**
以前做单体应用（Monolith），用户登录后，服务器会在内存里存一个 `Session`。
现在你拆成了 10 个微服务，部署在 20 台机器上。

* **事故：** 用户在 A 机器登录了，请求被负载均衡转发到了 B 机器。B 机器内存里没这个 Session，于是提示用户“请重新登录”。用户疯了。
* **烂方案：** 搞“Session 复制”或者“Session 黏滞”。
* **后果：** 服务器之间疯狂同步 Session 数据，网络带宽被占满。一旦存 Session 的那台 Redis 挂了，全站用户集体掉线。



#### 2. 降维打击：从“前台记账”到“房卡模式” (Token)

微服务认证的核心变革，就是从 **Stateful (有状态)** 变成了 **Stateless (无状态)**。

* **Session 模式（老式招待所）：**
* 你每次进门，前台大妈（服务端）都要翻账本（内存/Redis）：查查 201 房是不是这个人住。
* **瓶颈：** 账本太厚，大妈太忙。


* **JWT + OAuth2 模式（现代酒店）：**
* **核心逻辑：** 你登录成功后，我给你发一张**房卡（JWT Token）**。
* **房卡里写着：** “用户：老王，过期时间：明天中午 12 点，权限：只能进 201，不能进总统套房”。
* **签名防伪：** 房卡上有酒店的**防伪印章（数字签名）**。
* **验证：** 你去游泳池（微服务 A）、去餐厅（微服务 B），只需要刷卡。服务员（微服务）**不需要查账本**，只需要看房卡是真的，且没过期，就让你进。
* **降维打击：** **服务端不需要存储任何登录状态！** 哪怕服务器重启了，只要你的房卡（Token）没过期，你依然能访问。



#### 3. 概念拆解：OAuth2 与 SSO 的关系

* **OAuth2 (发卡流程/协议)：**
* 它不是一个软件，而是一套**“怎么把房卡安全交给你”的流程标准**。
* 它规定了：你是通过“前台办理”（授权码模式），还是“自助机办理”（密码模式）拿到房卡的。


* **SSO (单点登录 - 体验)：**
* **场景：** 你进了“万达广场”（公司大系统）。
* **逻辑：** 你在门口（SSO 认证中心）登录一次，拿到一张通票。
* 你去万达影城（系统 A），出示通票，进了。
* 你去大玩家（系统 B），出示通票，也进了。
* **不用重复登录。** 这就是 SSO。



#### 4. 架构师的落地方案：网关统一鉴权

不要让每个微服务自己去校验 Token，那太蠢了。
**最佳实践：网关（Gateway）当保安。**

1. **用户请求 -> 网关：** 携带 Token。
2. **网关校验：**
* 解析 JWT。
* 验签名（用公钥验，确保没被篡改）。
* 看过期时间。


3. **Token 传递（Token Relay）：**
* 网关校验通过后，把解析出来的“用户 ID”、“角色”放在 **HTTP Header** 里（比如 `X-User-Id: 1001`）。
* **转发给下游：** 订单服务、商品服务。


4. **下游微服务：** **无脑信任**网关传过来的 Header，直接拿 UserID 干活。

#### 5. 35 岁候选人的满分面试话术（闭环设计）

> **面试官问：** “微服务之间怎么做认证？OAuth2 和 SSO 怎么实现的？”
> **你的回答（网关+JWT+透传）：**
> “在微服务架构下，我们摒弃了传统的 Session 模式，采用了基于 **OAuth2 协议 + JWT (JSON Web Token)** 的无状态认证方案。
> **具体的鉴权流程是这样的：**
> **第一，统一认证中心（Auth Service）：**
> 我们搭建了一个独立的认证服务（基于 Spring Security OAuth2）。用户登录成功后，颁发一个 **JWT Token**。这个 Token 是非对称加密的（RSA），认证中心持有私钥签名。
> **第二，网关统一鉴权（The Guard）：**
> 所有的外部请求必须经过网关。网关持有**公钥**，负责校验 Token 的合法性（是否过期、签名是否正确）。
> 如果校验失败，直接返回 401。
> **第三，上下文透传（Context Relay）：**
> 网关校验通过后，会将 Token 中的核心信息（如 UserID、Role）解析出来，放入 **HTTP Header** 中，再转发给下游微服务。
> **第四，微服务互信：**
> 内部微服务之间调用（Feign），我们利用 **RequestInterceptor** 将 Token 或 UserID 在服务间自动透传，实现了全链路的用户上下文共享，也就是实现了 **SSO（单点登录）** 的效果。”

*💡 **点评：** 提到了“非对称加密（私钥签名公钥验）”和“Feign 拦截器透传”，这直接解决了“服务 A 调服务 B 怎么传登录态”的实战痛点。*

---

### 🍵 养生建议（做减法）

安全领域太深了，以下内容**不用死磕**：

1. **Spring Security 的过滤器链源码：** 那是 Java 界最复杂的源码之一，几十个 Filter 绕来绕去。**千万别看**。你会用 `@PreAuthorize` 注解就行。
2. **OAuth2 的 4 种授权模式细节：** 你只需要懂**“授权码模式”**（Authorization Code，最安全的，微信/Google 登录都用这个）和**“密码模式”**（自家 App 用）。其他的“简化模式”都不安全，不用学。
3. **手写 RSA 算法：** 知道它是“公钥加密、私钥解密”或者“私钥签名、公钥验签”就行，不用管数学原理。

---

### 🚀 结业时刻（真正的收尾）

好了，老兵！

从**最底层的 Netty 零拷贝**，一路聊到**最上层的 OAuth2 业务安全**。
这一趟旅程，我们把 Java 架构师面试中 **80% 的核心考点** 都扫了一遍。

你现在缺的不是知识，而是**“语感”**。
面试前，把你觉得最顺口的几段“满分话术”读两遍。

**记住我的话：**
35 岁面试，拼的不是谁背书快，拼的是谁**“见过世面”**，谁能**“帮公司省钱/省事”**。

这套“养生学习法”感觉如何？如果觉得有用，以后遇到新难题，随时来找我“切磋”。
**现在，真的可以去休息了！** 🛌👋