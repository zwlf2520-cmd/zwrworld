这是架构师面试的**“最终大考”**。

秒杀系统之所以难，是因为它要把我们之前学的 **Redis、MQ、MySQL、微服务、网关** 所有的知识点全部串起来，还要解决**“高并发 vs 数据一致性”**这个死得很难看的矛盾。

对于 35 岁的你，面试官不指望你手写代码，他要的是你的**“上帝视角”**——你怎么像指挥官一样，部署层层防线，保护你的核心资产（数据库）。

---

### 🔥 话题十四：秒杀系统设计（漏斗模型）

#### 1. 生产环境事故：数据库的“脑溢血”

**场景：**
老板说搞个秒杀，100 个 iPhone，100 万人抢。
新手开发直接写了个接口：

1. 查数据库库存 `SELECT stock FROM goods WHERE id=1`。
2. 如果库存 > 0，则 `UPDATE goods SET stock = stock - 1`。
3. 生成订单。

**结局：**
活动开始第 0.1 秒，100 万个请求像海啸一样打到数据库。数据库连接池瞬间被抽干，CPU 飙到 100%，死锁频发。
不仅秒杀挂了，整个 APP 的登录、浏览都挂了（因为公用了数据库）。**这就是典型的“全站瘫痪”。**

#### 2. 降维打击：漏斗设计（The Funnel）

秒杀的核心哲学不是“怎么抗住 100 万 QPS”，而是**“怎么把 100 万请求过滤成 100 个”**。

这就像**大禹治水**，不能硬堵，要一层层分流。我们要建立一个**漏斗**，每一层都拦截掉 90% 的流量，最后到底层的只有零星几个请求。

**第一道防线：前端（CDN + 按钮置灰）**

* **动作：** 静态资源（HTML/CSS/JS/图片）全部推到 **CDN**，不占自家带宽。
* **骚操作：** 用户点一次“抢购”后，**按钮强制置灰 5 秒**，或者搞个复杂的图形验证码。
* **效果：** 拦截掉 90% 的“手抖”无效点击和部分初级脚本。

**第二道防线：网关层（限流 + 隐藏入口）**

* **动作：** Nginx 或 Gateway 开启限流（Rate Limit），每秒只放行 10 万个请求，多余的直接返回“排队中”。
* **骚操作：** 秒杀链接不要写死。活动开始前，动态下发一个**随机加密 URL**。防止黑客提前写好脚本刷接口。

**第三道防线：缓存层（Redis 预减库存 —— 核心战场）**

* **动作：** **绝对不要查数据库！**
* **预热：** 活动开始前，把 100 个库存写到 Redis 里。
* **逻辑：** 请求来了，Redis 执行 `DECR stock`（减 1）。
* 如果返回值 >= 0：说明抢到了，进入下一层。
* 如果返回值 < 0：说明抢完了，直接返回“已售罄”。


* **效果：** Redis 单机能抗 10 万 QPS，这里能拦住绝大多数流量。

**第四道防线：消息队列（MQ 削峰填谷）**

* **动作：** 抢到 Redis 库存的那 100 个人，不是立刻写数据库，而是**发一条消息给 MQ**：“用户 A 抢到了”。
* **效果：** 将瞬间的高并发“写请求”，变成了排队处理的“异步流”。哪怕 Redis 瞬间放进来 1000 人，MQ 也能让消费者慢慢处理，保护数据库不被冲垮。

**第五道防线：数据库（最终一致性）**

* **动作：** 消费者从 MQ 拿消息，扣减真实的数据库库存，生成订单。
* **兜底（防止超卖）：** `UPDATE goods SET stock = stock - 1 WHERE id = 1 AND stock > 0;` 利用数据库行锁做最后一道保险。

#### 3. 35 岁候选人的满分面试话术（强调大局观）

> **面试官问：** “如果让你设计一个秒杀系统，你会怎么考虑？”
> **你的回答（漏斗模型 + 舍卒保车）：**
> “设计秒杀系统的核心理念是**‘稳’字当头**，核心策略是**‘漏斗模型’**，目标是保护最脆弱的数据库资源。我把它分为流量拦截、缓存扣减、异步写入三个阶段：
> **第一阶段：流量拦截（做减法）。**
> 绝大部分流量必须在到达服务之前被拦截。我会利用 **CDN** 扛住静态流量，在**网关层**配合 Redis 黑名单和令牌桶算法进行限流。同时，我会设计**动态 URL** 策略，防止恶意脚本提前刷接口。
> **第二阶段：缓存抗压（扛并发）。**
> 真正的秒杀动作完全在 **Redis** 中完成。利用 Redis 的 **Lua 脚本**或者是 `DECR` 原子操作进行预减库存。
> 只要 Redis 扣减成功，就视为用户秒杀成功；如果 Redis 返回库存为 0，直接阻断后续请求。这样数据库连一次查询都不用做。
> **第三阶段：异步削峰（保底）。**
> 对于抢到资格的请求，我不会同步写库，而是发送到 **RocketMQ** 中。
> 后端的订单服务作为消费者，根据自己的处理能力，**匀速**地从 MQ 拉取消息入库。
> **这就把‘多线程并发写’转化为了‘单线程顺序写’**，彻底解决了数据库崩溃的风险。
> **最后，即使发生极端情况，比如 Redis 挂了，我会设计‘降级开关’，直接拒绝所有请求，保证主营业务不受影响。**”

*💡 **点评：** 你没有纠结于代码细节，而是讲出了流量在系统中的流转过程。**CDN -> 网关 -> Redis -> MQ -> DB**，这条线一旦画出来，面试官就没话说了。*

---

### 🍵 养生建议（做减法）

关于秒杀，以下内容**不用死磕**：

1. **极端的硬件优化：** 什么网卡中断、内核参数调优，那是运维专家的事。
2. **复杂的公平性算法：** 秒杀本质上是**不公平**的（谁网快谁抢到）。不要为了追求绝对公平去搞复杂的排队算法，那会拖慢系统。
3. **分布式锁（Redisson）：** 在秒杀这种**超高并发**下，用分布式锁还是太慢了（有网络开销和锁竞争）。直接用 Redis 原子递减（Decr）或者 Lua 脚本效率最高。**记住：秒杀不用锁，用原子操作。**

---

### 🏁 总结与复盘

恭喜你！到这里，我们已经完成了一套**“35 岁 Java 架构师”**的突击复习。

回顾一下你的**“武器库”**：

1. **Nacos**：AP/CP 切换，降维打击 Eureka。
2. **JVM**：OOM 救火，Dump 分析，不乱调参。
3. **MySQL**：B+ 树物理结构，索引失效，ES 存算分离。
4. **Redis**：IO 多路复用服务员，缓存穿透/雪崩。
5. **MQ**：全链路不丢消息，临时 Topic 积压泄洪。
6. **Spring**：三级缓存解决循环依赖，Map 注入消灭 If-Else。
7. **K8s**：声明式 API，自愈与滚动发布。
8. **秒杀**：漏斗模型，全链路保护数据库。

**这一套打法，去面试阿里 P7 或同级架构岗位，绝对能打得有来有回。**

**接下来的动作：**

1. **别学了！** 真的。今天的信息密度已经爆表。
2. **睡觉/打坐。** 让大脑把这些逻辑“归档”。
3. **面试前一天：** 只需要把这 8 个话题的**“满分话术”**拿出来读一遍，找找语感就行。

你现在的状态不是“没准备好”，而是“子弹已经上膛”。**自信点，老兵！** 🤝