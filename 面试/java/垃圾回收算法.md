# 垃圾回收算法

## 回答重点

Java 中的垃圾回收算法主要有以下几种：

**标记-清除算法（Mark-Sweep）**：
Markdown All in One
* **工作原理**：首先遍历堆中的对象，标记出所有的存活对象，接着清除未标记的对象。
* **优点**：实现简单，能够处理堆中的所有对象。
* **缺点**：标记和清除的过程会产生内存碎片，影响后续内存分配的效率。

**标记-整理算法（Mark-Compact）**：

* **工作原理**：首先标记出所有存活的对象，然后将存活的对象整理到一边，最后清除未标记的对象。
* **优点**：避免了内存碎片问题。
* **缺点**：整理阶段需要移动对象，会导致额外的开销。

**复制算法（Copying）**：

* **工作原理**：将内存分成两部分，每次只使用其中一半，垃圾回收时将存活的对象从一半复制到另一半，清除原区域的所有对象（朴素的复制算法是这样的，实际使用会分为两个 survivor 和一个 eden 区）。
* **优点**：无需处理内存碎片，分配效率高。
* **缺点**：需要双倍的内存空间，浪费了一半的空间。


## java 中内存碎片有哪些问题？

在 Java 中，内存碎片主要带来以下问题：

1. **降低内存利用率**：大量小碎片导致可用内存无法被大对象分配，造成空间浪费。
2. **分配失败**：虽然总内存充足，但无法找到连续足够大的空间分配新对象，导致分配失败或频繁触发 GC。
3. **性能下降**：碎片化严重时，GC 需要花更多时间整理和移动对象，影响应用性能。
4. **增加 GC 频率**：碎片多时，垃圾回收器更频繁地进行整理和回收，影响系统响应速度。

因此，现代垃圾回收算法（如标记-整理、复制算法）都在努力减少或消除内存碎片问题。
