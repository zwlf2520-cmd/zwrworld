索引的类型可以根据其物理存储顺序、数据是否唯一、以及索引所包含的列等进行分类。

**索引的类型 (通用)**

1.  **聚簇索引 (Clustered Index)**
    *   决定数据在磁盘上的物理存储顺序。
    *   一个表只能有一个聚簇索引。
    *   数据行本身存储在索引的叶子节点中。
    *   通过聚簇索引查询数据非常快，因为它直接指向数据行。

2.  **非聚簇索引 (Non-Clustered Index)**
    *   不决定数据在磁盘上的物理存储顺序。
    *   一个表可以有多个非聚簇索引。
    *   索引的叶子节点不存储数据行本身，而是存储指向实际数据行的指针（例如，聚簇索引键或行ID）。
    *   查询数据时，需要先通过非聚簇索引找到数据行的位置，然后再去数据文件读取数据（可能需要回表操作）。

3.  **唯一索引 (Unique Index)**
    *   确保索引列中的所有值都是唯一的。
    *   可以防止在索引列中插入重复值。
    *   一个表可以有多个唯一索引。

4.  **普通索引 (Non-Unique/Secondary Index)**
    *   允许索引列中包含重复值。
    *   主要用于加速查询。

5.  **全文索引 (Full-Text Index)**
    *   用于在大量文本数据中进行关键词搜索，例如文章内容。
    *   支持模糊查询和相关性排序。

6.  **空间索引 (Spatial Index)**
    *   用于对地理空间数据进行索引，例如地理位置坐标。
    *   支持空间查询，如查找某个区域内的点。

7.  **复合索引 (Composite/Multi-column Index)**
    *   包含多个列的索引。
    *   查询时，如果查询条件包含复合索引的左边前缀列，可以利用该索引。

**MySQL 中的索引**

MySQL 中常见的索引类型与上述通用分类基本对应，但具体实现和命名可能有所不同，特别是对于不同的存储引擎。InnoDB 存储引擎是 MySQL 的默认和最常用的存储引擎：

1.  **主键索引 (PRIMARY KEY)**
    *   在 InnoDB 存储引擎中，主键索引就是**聚簇索引**。它决定了表中数据行的物理存储顺序。每个表只能有一个主键。
    *   如果表没有显式定义主键，InnoDB 会选择一个唯一的非空索引作为主键，如果也没有这样的索引，InnoDB 会隐式创建一个隐藏的聚簇索引。

2.  **唯一索引 (UNIQUE)**
    *   确保索引列中的值是唯一的，并且可以是 `NULL` (除非同时指定 `NOT NULL`)。
    *   在 InnoDB 中，唯一索引是非聚簇索引。

3.  **普通索引 (INDEX / KEY)**
    *   最基本的索引类型，允许重复值。
    *   在 InnoDB 中，普通索引是非聚簇索引。

4.  **全文索引 (FULLTEXT)**
    *   用于文本搜索，通常在 `VARCHAR`, `CHAR`, `TEXT` 列上创建。

5.  **空间索引 (SPATIAL)**
    *   用于存储地理空间数据 (如 `GEOMETRY` 类型)。

6.  **前缀索引 (Prefix Index)**
    *   对字符串类型列的前 n 个字符进行索引，可以减小索引大小，提高查询效率，但可能降低精确度。
    *   例如：`CREATE INDEX idx_name ON my_table (my_column(10));`

**索引的底层逻辑**

大多数数据库系统（包括 MySQL 的 InnoDB 存储引擎）的索引底层都基于 **B+ 树 (B+ Tree)** 数据结构。

**B+ 树 的工作原理：**

*   **多层结构：** B+ 树是一种平衡树，有多个层级。
*   **节点：**
    *   **根节点 (Root Node)：** 树的入口点。
    *   **内部节点 (Internal Nodes)：** 包含索引键和指向子节点的指针。这些节点只存储键，不存储实际数据。
    *   **叶子节点 (Leaf Nodes)：** 位于树的最底层。
        *   **聚簇索引的叶子节点：** 直接存储了完整的数据行。所有的叶子节点通过指针连接起来，形成一个有序的链表，使得范围查询非常高效。
        *   **非聚簇索引的叶子节点：** 存储索引键以及指向对应数据行的“书签”（对于 InnoDB，这个书签就是主键值）。
*   **有序性：** B+ 树中的所有键都是有序存储的。
*   **平衡性：** 树的每个分支的深度大致相同，确保了查询效率的稳定。

**查询过程：**

当数据库需要查找某个键值时，它会从根节点开始，通过比较键值，沿着树的路径向下遍历，直到找到对应的叶子节点。

1.  **等值查询 (e.g., `WHERE id = 100`)：**
    *   从根节点开始。
    *   在每个内部节点中，根据查询的键值，选择合适的子节点指针继续向下。
    *   最终达到叶子节点，如果索引是聚簇索引，则直接获取数据；如果是非聚簇索引，则获取主键值（或行ID），再通过主键索引（或行ID）去查找完整数据行（这个过程称为“回表”）。

2.  **范围查询 (e.g., `WHERE salary BETWEEN 3000 AND 5000`)：**
    *   首先通过 B+ 树找到范围的起始点（例如 `salary = 3000` 所在的叶子节点）。
    *   然后利用叶子节点之间的链表结构，顺序遍历后续的叶子节点，直到找到范围的结束点（`salary = 5000`）。这比全表扫描效率高得多。

**B+ 树 的优势：**

*   **磁盘友好：** 节点的大小通常设计为磁盘页面的倍数，使得每次磁盘I/O可以读取更多的数据，减少磁盘寻道次数。
*   **查询高效：** 无论查询是等值查询还是范围查询，都能在对数时间内完成。
*   **插入/删除高效：** 插入和删除操作也相对高效，因为 B+ 树会自动进行平衡和分裂/合并节点，以保持树的结构。

唯一索引，普通索引，复合索引等是非聚簇索引吗？
是的，在 MySQL 的 InnoDB 存储引擎中：

*   **唯一索引 (UNIQUE Index)**：是非聚簇索引。
*   **普通索引 (INDEX / KEY)**：是非聚簇索引。
*   **复合索引 (Composite Index)**：也是非聚簇索引，除非它是表的主键（在这种情况下，它就变成了聚簇索引）。

简单来说，除了主键索引（它是聚簇索引），InnoDB 表中的其他所有索引都是非聚簇索引。