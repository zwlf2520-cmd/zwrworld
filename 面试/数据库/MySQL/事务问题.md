脏读（Dirty Read）、不可重复读（Non-repeatable Read）和幻读（Phantom Read）是数据库事务并发执行时可能出现的三种不一致性问题。

### 1. 脏读 (Dirty Read)

**定义：** 一个事务读取了另一个尚未提交的事务修改的数据，如果修改数据的事务最终回滚，那么第一个事务读取到的数据就是“脏数据”。

**示例：**
1.  事务 A 将 `account` 表中 `user_id = 1` 的 `balance` 从 100 更改为 200。
2.  事务 B 读取了 `user_id = 1` 的 `balance`，得到 200。
3.  事务 A 由于某种原因回滚，`balance` 恢复为 100。
4.  此时，事务 B 读取的 200 就是一个脏数据，因为它从未真实存在于数据库中。

### 2. 不可重复读 (Non-repeatable Read)

**定义：** 一个事务在同一个事务中多次读取同一条数据，结果发现数据被另一个已提交的事务修改，导致前后读取的数据不一致。

**示例：**
1.  事务 A 读取 `user_id = 1` 的 `name` 为 'Alice'。
2.  事务 B 修改 `user_id = 1` 的 `name` 为 'Bob'，并提交。
3.  事务 A 再次读取 `user_id = 1` 的 `name`，结果为 'Bob'。
4.  在同一个事务 A 中，两次读取 `user_id = 1` 的 `name` 结果不同。

### 3. 幻读 (Phantom Read)

**定义：** 一个事务在同一个事务中多次执行同一查询，发现查询结果集的行数发生了变化（增加了或减少了行），这是因为另一个已提交的事务插入或删除了符合查询条件的新行。

**示例：**
1.  事务 A 查询所有 `age > 30` 的用户，发现有 5 条记录。
2.  事务 B 插入了一条新用户记录，`age` 为 35，并提交。
3.  事务 A 再次查询所有 `age > 30` 的用户，发现有 6 条记录。
4.  在同一个事务 A 中，两次查询的结果集发生了变化，就好像出现了“幻影”行。

### MySQL 如何解决这些问题？

MySQL 通过设置不同的**事务隔离级别（Transaction Isolation Levels）**来解决这些问题。ANSI/ISO SQL 标准定义了四种隔离级别，MySQL（特别是 InnoDB 存储引擎）都支持：

1.  **READ UNCOMMITTED (未提交读)**
    *   **允许脏读、不可重复读和幻读。**
    *   级别最低，并发性最高，但数据一致性最差。
    *   MySQL 默认不使用此级别。

2.  **READ COMMITTED (提交读)**
    *   **解决了脏读问题。**
    *   **允许不可重复读和幻读。**
    *   一个事务只能读取到已提交的数据。
    *   Oracle 数据库的默认隔离级别。

3.  **REPEATABLE READ (可重复读)**
    *   **解决了脏读和不可重复读问题。**
    *   **允许幻读（但在 InnoDB 中，通过间隙锁解决了大部分幻读问题）。**
    *   一个事务在整个过程中多次读取同一行数据，结果总是一致的。
    *   **MySQL InnoDB 存储引擎的默认隔离级别。**
    *   **解决不可重复读的机制：** InnoDB 通过**MVCC (Multi-Version Concurrency Control，多版本并发控制)** 来实现。每个事务看到的数据版本在事务开始时就已经确定。即使其他事务修改并提交了数据，当前事务看到的仍然是它开始时的数据版本。
    *   **解决幻读的机制：** 尽管标准定义 `REPEATABLE READ` 允许幻读，但 InnoDB 在此级别通过**间隙锁 (Gap Locks)** 和**邻键锁 (Next-Key Locks)** 解决了幻读问题。当一个事务在某个范围内进行查询时，不仅会锁定查询到的记录，还会锁定这些记录之间的“间隙”，防止其他事务在这个间隙中插入新数据。

4.  **SERIALIZABLE (串行化)**
    *   **解决了脏读、不可重复读和幻读问题。**
    *   级别最高，并发性最低。
    *   强制事务串行执行，避免了所有并发问题。
    *   通过对所有读取的行加锁（共享锁）来实现。

**在 MySQL 中设置隔离级别：**

你可以使用以下命令查看或设置当前会话或全局的事务隔离级别：

*   **查看当前会话的隔离级别：**
    ```sql
    SELECT @@transaction_isolation;
    -- 或者
    SELECT @@session.transaction_isolation;
    ```
*   **查看全局的隔离级别：**
    ```sql
    SELECT @@global.transaction_isolation;
    ```
*   **设置当前会话的隔离级别：**
    ```sql
    SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    -- 或 READ COMMITTED, REPEATABLE READ, SERIALIZABLE
    ```
*   **设置全局的隔离级别：**
    ```sql
    SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    ```

**总结解决策略：**

*   **脏读：** MySQL 默认的 `REPEATABLE READ` 级别（以及 `READ COMMITTED` 和 `SERIALIZABLE`）可以有效避免。
*   **不可重复读：** MySQL 默认的 `REPEATABLE READ` 级别（以及 `SERIALIZABLE`）通过 MVCC 机制可以有效避免。
*   **幻读：** MySQL InnoDB 的 `REPEATABLE READ` 级别通过间隙锁和邻键锁机制，在很大程度上避免了幻读。`SERIALIZABLE` 级别则完全避免。

选择合适的隔离级别需要在数据一致性和并发性之间做出权衡。对于大多数应用，MySQL 默认的 `REPEATABLE READ` 级别已经提供了足够的数据一致性，并且通过 MVCC 和锁优化，保持了良好的并发性能。