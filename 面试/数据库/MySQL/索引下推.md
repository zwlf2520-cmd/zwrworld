索引下推（Index Condition Pushdown，简称ICP）是MySQL 5.6版本引入的一项优化，用于改进查询性能。

**什么是索引下推？**

在没有索引下推的情况下，当查询使用到复合索引时，存储引擎（如InnoDB）会根据索引的前缀部分检索数据，并将所有符合前缀条件的完整行数据返回给MySQL服务器层。服务器层再对这些行数据进行剩余条件的过滤。

索引下推的优化在于，如果查询条件中包含索引列且这些条件不在索引的最左前缀中，存储引擎会在检索到索引记录时，先在存储引擎层对这些索引列的条件进行过滤。只有满足条件的索引记录对应的完整行数据才会被读取并返回给服务器层。这减少了存储引擎层需要读取的完整行数据量，以及服务器层需要接收和处理的数据量。

**如何使用？**

索引下推是MySQL的内部优化机制，它会在满足特定条件时自动启用，用户不需要显式地开启或关闭。要利用索引下推，你需要确保查询条件满足以下几点：

1.  **使用复合索引：** 索引下推仅对复合索引（联合索引）有效。
2.  **查询条件包含索引列：** 查询中WHERE子句的条件必须至少包含索引中的部分列，并且这些条件中有些是非索引前缀部分的列。
3.  **查询类型：** 适用于`SELECT`、`UPDATE`、`DELETE`语句。
4.  **不适用于全文本索引或空间索引。**
5.  **不适用于子查询中的条件。**

**示例：**

假设有一个表 `users`，包含 `first_name`、`last_name` 和 `age` 字段，并在 `(first_name, last_name)` 上创建了一个复合索引。

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    age INT
);

CREATE INDEX idx_name ON users (first_name, last_name);
```

考虑以下查询：

```sql
SELECT * FROM users WHERE first_name = 'John' AND last_name LIKE 'S%' AND age > 30;
```

*   **没有索引下推（早期版本行为）：**
    1.  存储引擎会使用 `idx_name` 索引找到所有 `first_name = 'John'` 且 `last_name` 以 `S` 开头的索引条目。
    2.  对于每个匹配的索引条目，存储引擎会回表获取完整的行数据（包括 `age` 字段）。
    3.  所有这些完整的行数据被发送到MySQL服务器层。
    4.  服务器层再对这些行数据应用 `age > 30` 的条件进行过滤。

*   **启用索引下推（MySQL 5.6+）：**
    1.  存储引擎会使用 `idx_name` 索引找到所有 `first_name = 'John'` 且 `last_name` 以 `S` 开头的索引条目。
    2.  **在存储引擎层，** 会利用索引包含的信息（`first_name` 和 `last_name`）以及查询条件中关于 `last_name` 的条件 (`last_name LIKE 'S%'`) 进行初步过滤。
    3.  如果索引覆盖了 `age` 字段，甚至可以在存储引擎层直接过滤 `age > 30` 的条件。如果 `age` 不在索引中，但 `age > 30` 条件在 `WHERE` 子句中，并且与索引列一起使用，存储引擎会尝试在回表前先评估哪些索引条目可能不满足条件，从而减少回表的次数。虽然本例中 `age` 不在索引中，但索引下推仍能优化 `last_name LIKE 'S%'` 的处理。如果查询是 `SELECT first_name, last_name FROM users WHERE first_name = 'John' AND last_name LIKE 'S%' AND age > 30;` 并且 `age` 不在索引中，索引下推会主要作用于 `last_name LIKE 'S%'`。
    4.  只有满足条件的索引条目对应的完整行数据才会被回表读取。
    5.  然后，这些较少的回表读取的行数据被发送到服务器层进行最终的 `age > 30` 过滤（如果 `age` 不在索引中）。

通过 `EXPLAIN` 语句可以查看查询计划中是否使用了索引下推，通常会在 `Extra` 列显示 `Using index condition`。