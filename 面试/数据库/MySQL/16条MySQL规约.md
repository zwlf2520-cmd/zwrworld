这16条MySQL规约，分享给大家，欢迎评论指正。

# 1. 禁止使用select  *
阿里开发规范中，有这么一句话： select * 会查询表中所有字段，如果表中的字段有更改，必须修改SQL语句，不然就会执行错误。 查询出非必要的字段，徒增磁盘IO和网络延迟。

# 2. 用小表驱动大表
关联查询的时候，先用小表查到结果，再用结果去大表查询，可以大大减少连接次数。 比如我们要查询某个部门下的员工，由于部门数量远远小于员工数量。我们可以把部门表当作驱动表，员工表当作被驱动表。 查询SQL类似这样：


select * from department
inner join employee
on department.id=employee.department_id
where department_name='部门1';
# 3. join关联表不宜过多
join关联表禁止超过3张，join关联过多，不但会增加查询时间，降低查询性能，还会产生临时表缓存结果数据，推荐拆成多条小SQL执行。 另外关联字段的类型一定要保持一致，并且在每张表都要建立关联字段的索引。

# 4. 禁止使用左模糊或者全模糊查询
当我们在SQL查询使用左模糊或者全模糊匹配的时候，类似下面这样：

左模糊查询
select * from user where name='%一灯';
全模糊查询
select * from user where name='%一灯%';
根据B+树的特性，即使我们在name字段上建立了索引，查询的时候也是无法用到索引的。

# 5. 索引访问类型至少达到range级别
索引访问类型常见的有这几个级别，从上到下，性能由好到差。 image-20220731223132721.png

要求SQL索引访问类型至少要达到range级别，最好到const级别。

# 6. 更优雅的使用联合索引
由于联合索引有最左匹配原则，所以需要优先把区分度高的字段放在最左边第一列。 比如要统计用户表中生日字段和性别字段区分度，可以这样统计：


select 
    count(distinct birthday)/count(*), 
    count(distinct gender)/count(*) 
from user;
值越大，区分度越高。 出道面试题，下面这条SQL该怎么创建联合索引：


select a from table_name where b=1 order by c;
SQL中用到abc三个字段，创建联合索引的顺序是**（b,c,a）**。 这道题还涉及到另一个知识点，SQL执行的顺序：

from > on > join > where > group by > having > select > distinct > order by > limit

# 7. 注意避免深分页
MySQL深分页的时候，查询性能较差。


select * from user where name='一灯' limit 10000,10;
我们可以采用子查询的方式进行优化：


select * from user 
where id in (
  select id from user 
  where name='一灯'
  limit 10000,10
);
这样可以减少非聚簇索引回表查询的次数。

# 8. 单表字段不要超过30个
当单表字段数量过多的时候，加载大量数据也会拖慢查询性能。 如果字段超过30个，不用看，肯定是表设计的不合理。 这时候，可以拆成多张表，用垂直分表的方式，进行冷热字段分离。

# 9. 枚举字段不要使用字符类型
字符类型会占用更多的存储空间，当我们想要存储枚举值或者表示是否的时候，可以采用tinyint数值类型，最好采用无符号整数unsigned tinyint。

# 10. 小数类型禁止使用float和double
在存储和计算的时候，float 和 double 都存在精度损失的问题，无法得到正确的结果。 所以在涉及到存储小数的时候，必须使用decimal类型。

# 11. 所有字段必须设置默认值且不允许为null
字段允许为null，会占用额外的存储空间。 索引并不会索引null值，所以查询null值的时候无法用到索引。 当数值类型允许为null，返回给映射实体类的时候还可能会报空指针异常。

# 12. 必须创建主键，最好是有序数值类型
如果我们自己没有给表设置主键，InnoDB会自动增加一列隐藏的主键，我们无法使用到，并且也占用的更多的存储空间，所以建表的时候，必须设置主键。 有序数值更适合做主键，插入数据的时候，由于是有序的，不会频繁调整B+树结构，性能更好。

# 13. 快速判断是否存在某条记录
一般我们判断表中是否存在某条记录的时候，会使用count函数，然后判断返回值是否大于1。


select count(*) from user where name='一灯';
InnoDB存储引擎并没有像MyIsAm那样缓存表的总行数，每次查询都是实时计算的，耗时较长。 我们可以采用limit加快查询效率：


select id from user where name='一灯' limit 1;
limit 1表示匹配到一条就返回，查询效率更好，结果集只返回id，还可以用到覆盖索引。

# 14. in条件中数量不宜过多
in条件中数量不要超过1000个，不然耗时会非常长，可以拆成多批次查询。

# 15. 禁止创建预留字段
无法通过预留字段的名称判断这个字段是干嘛用的。 预留字段的类型不一定合适。 无法为预留字段创建合适的索引。

# 16. 单表索引数不要超过5个
创建适当的索引可以提高查询效率，但是过多的索引，不但占用更多存储空间，还会拖慢更新SQL的性能。 所以，索引好用，适度即可。

# 17. 修改操作之前先查询
在执行update、delete语句之前需要先执行select操作，查询出主键ID之后，使用主键ID进行update、delete操作。 下面的操作是不推荐的：


'直接更新订单状态（不推荐）
update status='deleted' from order where status='canceled';
直接删除订单（不推荐）
delete from order where status='deleted';
'
推荐使用下面的操作：


先查询出主键ID，更新订单状态（推荐）
select id from where status='canceled';
update status='deleted' from order where id in (?,?,?);

先查询出主键ID，再删除订单（推荐）
select id from where status='deleted'; 
delete from order where id in (?,?,?);
使用第二种操作，锁定的行数更少，使用主键ID执行的操作更快，还能分批操作，审计日志还能记录具体更新了哪些数据。


以下是 MySQL 使用的一些常见规约：

### **一、表设计规范**

1.  **命名规范**：
    *   表名、字段名必须使用小写字母，并使用下划线分隔。例如：`user_info`。
    *   禁用保留字，如 `desc`, `range`, `match` 等。
    *   表名、字段名应具有明确的含义，不建议使用缩写。

2.  **选择合适的数据类型**：
    *   根据数据实际范围和类型选择最小、最合适的数据类型。例如，能用 `TINYINT` 就不用 `INT`，能用 `VARCHAR` 就不用 `TEXT`。
    *   字符类型要定义长度，例如 `VARCHAR(20)`。
    *   避免使用 `TEXT/BLOB` 类型存储大文本或二进制数据，考虑使用文件系统存储并存储路径。

3.  **非空约束 (NOT NULL)**：
    *   所有列都应该定义为 `NOT NULL`，并提供默认值，除非业务逻辑确实允许为空。`NULL` 会导致索引失效、计算困难，并增加存储空间。

4.  **默认值 (DEFAULT)**：
    *   为所有 `NOT NULL` 的列设置明确的默认值，特别是字符串类型（空字符串 `''`）和数字类型（`0`）。时间戳通常可设置为 `CURRENT_TIMESTAMP`。

5.  **主键规范**：
    *   所有表都应该有主键，建议使用代理主键，如自增 `INT` 或 `BIGINT` 类型。主键不应包含业务逻辑。

6.  **避免过多字段**：
    *   单表字段不宜过多，通常建议不超过 20-30 个。如果表字段过多，考虑垂直拆分。

### **二、索引规范**

7.  **合理使用索引**：
    *   在 `WHERE` 子句、`JOIN` 子句、`ORDER BY` 子句、`GROUP BY` 子句中经常使用的列上创建索引。
    *   索引不是越多越好，过多的索引会增加写入和存储开销。
    *   考虑使用覆盖索引，避免回表查询。

8.  **索引列顺序**：
    *   复合索引中，将区分度高（重复值少）的列放在前面。
    *   满足最左前缀原则。

9.  **避免冗余和重复索引**：
    *   例如，如果已经有了 `(a, b)` 上的复合索引，就无需再创建 `a` 上的独立索引。

### **三、SQL 编写规范**

10. **避免 `SELECT *`**：
    *   只查询需要的列，减少网络传输和内存消耗。

11. **`LIMIT` 优化 (深分页)**：
    *   避免大 `OFFSET` 的深分页查询。考虑使用子查询优化或书签法（`WHERE id > last_id LIMIT N`）。

12. **`JOIN` 优化**：
    *   `JOIN` 关联的列必须有索引，并且数据类型一致。
    *   优先使用 `INNER JOIN`，减少不必要的外部连接。

13. **避免在 `WHERE` 子句中对列进行函数操作或计算**：
    *   这会导致索引失效，例如 `WHERE DATE(create_time) = '2023-01-01'` 应改为 `WHERE create_time >= '2023-01-01' AND create_time < '2023-01-02'`。

### **四、事务和并发控制**

14. **短事务**：
    *   事务应尽可能短小，减少锁持有的时间，提高并发性能。避免在事务中进行用户交互、远程调用等耗时操作。

15. **避免死锁**：
    *   规范事务中 SQL 的执行顺序，确保所有事务都以一致的顺序访问共享资源。
    *   优化 SQL 语句和索引，减少锁定的范围和时间。

### **五、数据库操作与维护**

16. **大表优化**：
    *   对于千万级以上的大表，考虑进行水平或垂直拆分。
    *   避免单次操作处理大量数据，分批处理。