# Redis 缓存问题：穿透、击穿、雪崩及其处理

### 1. 缓存穿透 (Cache Penetration)

**是什么问题？**

缓存穿透是指查询一个**根本不存在**的数据，由于缓存中没有，数据库也没有，导致这个不存在的数据每次请求都会穿透缓存层，直接打到数据库层。如果恶意攻击者不断请求大量不存在的数据，会对数据库造成巨大压力，甚至拖垮数据库。

**危害：**

*   数据库直接承受所有请求压力，可能导致数据库宕机。
*   大量无效请求占用网络带宽和服务器资源。

**如何处理？**

1.  **缓存空值 (Cache Empty Object)：**
    *   **方法：** 当从数据库中查询不到数据时，将一个空对象（例如一个特定的空字符串或 `null` 值）也写入缓存，并设置一个较短的过期时间。
    *   **优点：** 后续对该不存在数据的请求都会直接从缓存中返回空值，不会再穿透到数据库。
    *   **缺点：**
        *   会占用额外的缓存空间（虽然是空值）。
        *   如果空值过期了，在下次查询到空值过期之间仍会有一小段时间的穿透。
        *   当数据从“不存在”变为“存在”时，需要主动将缓存中的空值删除，否则会出现数据不一致。

2.  **布隆过滤器 (Bloom Filter)：**
    *   **方法：** 在数据写入数据库时，同时将该数据的 ID（或其他唯一标识）添加到布隆过滤器中。当用户请求查询时，先通过布隆过滤器判断该 ID 是否存在。如果布隆过滤器判断不存在，则直接返回空，避免了对 Redis 和数据库的查询。
    *   **优点：**
        *   空间效率极高，可以存储大量 Key。
        *   判断速度快。
        *   能够有效拦截绝大部分非法请求。
    *   **缺点：**
        *   **存在误判率：** 布隆过滤器有一定概率将不存在的 Key 误判为存在（“假阳性”），此时请求仍然会穿透到 Redis 和数据库。
        *   **删除困难：** 很难从布隆过滤器中删除元素。如果数据被删除，布隆过滤器可能仍然认为它存在，导致查询数据库一个不存在的数据。

### 2. 缓存击穿 (Cache Breakdown)

**是什么问题？**

缓存击穿是指一个**热点 Key** 在缓存中过期（或被删除）的瞬间，同时有大量的并发请求去查询这个 Key。由于缓存中已经没有，这些请求会瞬间全部打到数据库层，导致数据库压力剧增。

**危害：**

*   数据库瞬间承受巨大压力，可能被击垮。
*   服务响应变慢或出现大量超时。

**如何处理？**

1.  **互斥锁 (Mutex Lock) / 分布式锁：**
    *   **方法：** 当缓存中的热点 Key 失效时，只有第一个请求能获得锁去查询数据库，并将数据回填到缓存。其他请求在等待锁的期间，可以稍作等待或直接返回旧数据（如果允许）或返回兜底数据。
    *   **优点：** 有效防止大量请求同时击穿数据库。
    *   **缺点：**
        *   增加了系统的复杂性，需要维护锁机制。
        *   未获得锁的请求需要等待，可能增加用户响应时间。
        *   分布式锁本身可能存在死锁等问题，需要确保其健壮性。

2.  **永不过期 (Never Expire) / 逻辑过期：**
    *   **方法：**
        *   **物理上不设置过期时间**：对于热点 Key，在缓存中不设置过期时间，或者设置一个非常长的过期时间。
        *   **逻辑过期：** 在缓存值中增加一个时间戳字段作为“逻辑过期时间”。当访问缓存时，检查这个逻辑时间戳是否过期。如果过期，则启动一个后台线程异步去更新缓存，并在此期间仍返回旧的（但仍存在于缓存中的）数据给用户。
    *   **优点：**
        *   避免了 Key 失效瞬间的击穿问题。
        *   逻辑过期方案可以在更新缓存时，不阻塞用户的读请求。
    *   **缺点：**
        *   如果数据更新不及时，可能会返回过期数据。
        *   需要手动管理缓存的更新。
        *   **内存占用：** 不设置过期时间可能会导致热点 Key 永远占用内存，除非主动删除。

3.  **二级缓存 / 本地缓存：**
    *   **方法：** 在应用层设置本地缓存（如 Guava Cache、Caffeine），当 Redis 中的热点 Key 失效时，请求可以先命中本地缓存，减轻对 Redis 的压力，从而也减轻了对数据库的压力。
    *   **优点：** 提高了访问速度，分担了 Redis 压力。
    *   **缺点：** 存在数据一致性问题，需要考虑缓存更新和失效策略。

### 3. 缓存雪崩 (Cache Avalanche)

**是什么问题？**

缓存雪崩是指在某个时间段内，缓存中**大量的 Key 同时过期**。或者 Redis 服务发生故障宕机。这两种情况都会导致大量的请求在很短的时间内全部涌向数据库，从而导致数据库压力过大甚至崩溃，进而影响整个应用服务的可用性。

**危害：**

*   数据库瞬间承受巨大压力，甚至宕机。
*   整个服务链条的性能急剧下降，造成大面积服务不可用。

**如何处理？**

1.  **分散 Key 的过期时间：**
    *   **方法：** 给缓存中的 Key 设置不同的过期时间，避免大量 Key 在同一时间失效。可以在原有过期时间的基础上，增加一个小的随机值。
    *   **例如：** `expire_time = base_expire_time + random(1, N)`。
    *   **优点：** 错开 Key 的过期时间，将请求压力分散到不同的时间点。
    *   **缺点：** 增加了过期时间管理的复杂性。

2.  **高可用部署 Redis：**
    *   **方法：** 部署 Redis 主从集群、哨兵 (Sentinel) 或集群 (Cluster) 模式，以确保 Redis 服务的高可用性。当某个节点宕机时，能够快速切换到备用节点，保证缓存服务的持续可用。
    *   **优点：** 避免了 Redis 单点故障导致的雪崩。
    *   **缺点：** 增加了部署和运维的复杂性。

3.  **服务熔断、限流、降级：**
    *   **方法：**
        *   **限流 (Rate Limiting)：** 在应用层限制对数据库的并发请求数量，当并发量超过阈值时，直接拒绝或排队请求。
        *   **熔断 (Circuit Breaker)：** 当检测到后端服务（如数据库）出现故障或响应缓慢时，快速失败所有请求，避免系统资源被耗尽。待后端服务恢复后再恢复正常请求。
        *   **降级 (Degradation)：** 在系统压力过大时，关闭部分非核心服务或非核心功能，保证核心功能的可用性。例如，不再显示实时评论，而是显示静态数据。
    *   **优点：** 保护后端系统不被冲垮，确保核心服务的可用性。
    *   **缺点：** 用户体验可能会受到影响。

4.  **数据预热 (Preheating)：**
    *   **方法：** 在系统上线前或某个大流量活动开始前，提前将可能的热点数据加载到缓存中，避免冷启动时缓存为空导致雪崩。
    *   **优点：** 避免了冷启动时对数据库的巨大冲击。

5.  **多级缓存：**
    *   **方法：** 引入本地缓存（如 Guava Cache、Caffeine）作为 Redis 的前置缓存。当 Redis 出现问题时，本地缓存仍能提供一部分服务，减轻对数据库的压力。
    *   **优点：** 提高了缓存命中率，进一步分散风险。
    *   **缺点：** 增加了系统复杂性和数据一致性挑战。

理解这些缓存问题及其处理策略，对于构建健壮、高性能的分布式系统至关重要。通常需要根据具体的业务场景和对数据一致性、实时性的要求，综合运用多种方案。